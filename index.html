<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Magic Christmas to Van</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<style>
body {
    margin: 0; overflow: hidden; background: #000;
    font-family: 'Segoe UI', sans-serif;
    touch-action: none; user-select: none;
}
#canvas-container { width: 100%; height: 100vh; }
#ui-layer {
    position: absolute; bottom: 30px; width: 100%;
    text-align: center; pointer-events: none; z-index: 100;
}
button {
    pointer-events: auto; cursor: pointer;
    background: linear-gradient(to bottom, #D32F2F, #8B0000);
    color: #FFF; border: 2px solid #FFD700;
    padding: 15px 50px; border-radius: 30px;
    font-weight: 800; font-size: 16px;
    animation: pulse 1.5s infinite;
}
@keyframes pulse { 0%{transform:scale(1);}50%{transform:scale(1.05);}100%{transform:scale(1);} }

#camera-preview {
    position: absolute; top: 15px; right: 15px;
    width: 120px; height: 90px;
    border: 2px solid rgba(255,255,255,0.5);
    opacity: .9; border-radius: 8px;
    object-fit: cover; background:black;
}
</style>

</head>
<body>

<div id="ui-layer">
    <div class="guide" style="color:white; margin-bottom:15px;">
        ‚úåÔ∏è <b>Hi:</b> Theme Tuy·∫øt &nbsp;|&nbsp; ü§ü <b>3 Ng√≥n:</b> Theme Chill <br>
        üñê <b>M·ªü:</b> Xoay &nbsp;|&nbsp; ‚úä <b>N·∫Øm:</b> C√¢y th√¥ng &nbsp;|&nbsp; üëå <b>Ch·ª•m:</b> Xem ·∫£nh
    </div>
    <button id="btnStart" onclick="startSystem()">START</button>
</div>

<div id="canvas-container"></div>
<video class="input_video" style="display:none" playsinline></video>
<canvas id="camera-preview"></canvas>


<script>
/* ============================================================
   üìå BASIC CONFIG
============================================================ */
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

const CONFIG = {
    audio: "./audio.mp3",
    particles: { gold: isMobile?1200:1800, red: isMobile?180:300, gift:isMobile?80:120 },
    baseRadius: isMobile?60:45,
    tree: { height:isMobile?110:70, radius:isMobile?50:35 },
    photos: [
        "./1.jpg","./2.jpg","./3.jpg","./4.jpg","./5.jpg","./6.jpg","./7.jpg","./10.jpg",
        "./11.jpg","./12.jpg","./13.jpg","./14.jpg","./15.jpg","./16.jpg","./19.jpg"
    ]
};

/* ============================================================
   üìå GLOBALS
============================================================ */
let scene, camera, renderer;
let groupGold, groupRed, groupGift;
let titleMesh, starMesh, loveMesh;
let photoMeshes = [];
let photoTextures = [];

let handX=0.5, handY=0.5, smoothX=0.5, smoothY=0.5;
let rotX=0, rotY=0;

let state="TREE";
let isSnow=false;
let bestPhoto=0;

let lastLogic=0;
const LOGIC_INTERVAL = 1000/30; // 30 FPS logic

/* ============================================================
   üìå  LOAD TEXTURES
============================================================ */
const loader = new THREE.TextureLoader();
for (let i=0;i<CONFIG.photos.length;i++){
    photoTextures[i] = loader.load(CONFIG.photos[i]);
}

/* ============================================================
   üìå INIT 3D
============================================================ */
function init3D(){
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000,0.002);

    camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);

    renderer = new THREE.WebGLRenderer({ antialias:!isMobile, alpha:false });
    renderer.setSize(innerWidth,innerHeight);
    renderer.setPixelRatio(isMobile?1.3:Math.min(window.devicePixelRatio,2));

    document.getElementById("canvas-container").appendChild(renderer.domElement);

    setCameraDist();
    createParticles();
    createPhotos();
    createDecor();

    animate();
}

/* ============================================================
   üìå CAMERA DIST
============================================================ */
function setCameraDist(){
    const padding = isMobile?1.5:1.4;
    const target = CONFIG.baseRadius * padding;

    const fov = camera.fov * Math.PI/180;
    const hDist = target / Math.sin(fov/2);

    const aspect = innerWidth / innerHeight;
    const wDist = target/(Math.sin(fov/2)*aspect);

    camera.position.z = Math.max(hDist,wDist);
}

/* ============================================================
   üìå PARTICLE SYSTEM (OPTIMIZED)
============================================================ */
function createParticles(){
    groupGold = makeParticleGroup(CONFIG.particles.gold, 2.0);
    groupRed  = makeParticleGroup(CONFIG.particles.red,  3.0);
    groupGift = makeParticleGroup(CONFIG.particles.gift, 3.0);

    scene.add(groupGold, groupRed, groupGift);
}

function makeParticleGroup(count, size){
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count*3);
    const color = new Float32Array(count*3);
    const phase = new Float32Array(count);

    const tree = new Float32Array(count*3);
    const explode = new Float32Array(count*3);
    const heart = new Float32Array(count*3);

    for (let i=0;i<count;i++){
        // TREE POS
        const h = Math.random()*CONFIG.tree.height;
        const y = h - CONFIG.tree.height/2;
        const r = (1 - h/CONFIG.tree.height)*CONFIG.tree.radius;
        const t = Math.random()*Math.PI*2;

        tree[i*3]   = r*Math.cos(t);
        tree[i*3+1] = y;
        tree[i*3+2] = r*Math.sin(t);

        pos[i*3] = tree[i*3];
        pos[i*3+1] = tree[i*3+1];
        pos[i*3+2] = tree[i*3+2];

        // EXPLODE SPHERE
        const u = Math.random();
        const v = Math.random();
        const th = 2*Math.PI*u;
        const ph = Math.acos(2*v-1);
        const rr = CONFIG.baseRadius*(0.6+0.6*Math.random());

        explode[i*3] = rr*Math.sin(ph)*Math.cos(th);
        explode[i*3+1] = rr*Math.sin(ph)*Math.sin(th);
        explode[i*3+2] = rr*Math.cos(ph);

        // HEART SHAPE
        const tt = Math.random()*Math.PI*2;
        let hx = 16*Math.pow(Math.sin(tt),3);
        let hy = 13*Math.cos(tt)-5*Math.cos(2*tt)-2*Math.cos(3*tt)-Math.cos(4*tt);
        let hf = Math.pow(Math.random(),0.3);

        heart[i*3] = hx*hf*2;
        heart[i*3+1] = hy*hf*2 + 5;
        heart[i*3+2] = (Math.random()-0.5)*8*hf;

        // Colors
        color[i*3] = 1; color[i*3+1] = 1; color[i*3+2] = 1;
        phase[i] = Math.random()*Math.PI*2;
    }

    geo.setAttribute("position", new THREE.BufferAttribute(pos,3));
    geo.setAttribute("color", new THREE.BufferAttribute(color,3));
    geo.setAttribute("phase", new THREE.BufferAttribute(phase,1));
    geo.userData = { tree, explode, heart, count };

    const mat = new THREE.PointsMaterial({
        size:size, transparent:true,
        opacity:1, vertexColors:true,
        blending:THREE.AdditiveBlending, depthWrite:false
    });

    return new THREE.Points(geo,mat);
}

/* ============================================================
   üìå PHOTOS
============================================================ */
function createPhotos(){
    const geo = new THREE.PlaneGeometry(8,8);
    const borderGeo = new THREE.PlaneGeometry(9,9);
    const borderMat = new THREE.MeshBasicMaterial({ color:0xFFD700 });

    for (let i=0;i<photoTextures.length;i++){
        const mat = new THREE.MeshBasicMaterial({ map:photoTextures[i] });

        const mesh = new THREE.Mesh(geo,mat);
        const border = new THREE.Mesh(borderGeo,borderMat);
        border.position.z=-0.1;
        mesh.add(border);

        mesh.visible=false;
        mesh.scale.set(0,0,0);

        // random sphere pos
        const u=Math.random(), v=Math.random();
        const t=2*Math.PI*u, p=Math.acos(2*v-1);
        const r=CONFIG.baseRadius*(0.7+0.6*Math.random());

        mesh.userData.origin = new THREE.Vector3(
            r*Math.sin(p)*Math.cos(t),
            r*Math.sin(p)*Math.sin(t),
            r*Math.cos(p)
        );
        scene.add(mesh);
        photoMeshes.push(mesh);
    }
}

/* ============================================================
   üìå DECORATIONS
============================================================ */
function createDecor(){
    // TITLE
    const cvs = document.createElement("canvas");
    cvs.width=1024; cvs.height=256;
    const ctx = cvs.getContext("2d");
    ctx.font = `bold italic ${isMobile?50:90}px "Times New Roman"`;
    ctx.fillStyle="#FFD700";
    ctx.textAlign="center";
    ctx.shadowColor="#FF0000"; ctx.shadowBlur=40;
    ctx.fillText("MERRY CHRISTMAS",512,140);

    titleMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(60,15),
        new THREE.MeshBasicMaterial({ map:new THREE.CanvasTexture(cvs), transparent:true })
    );
    titleMesh.position.set(0,50,0);
    scene.add(titleMesh);

    // STAR
    starMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(12,12),
        new THREE.MeshBasicMaterial({ color:0xFFFF00 })
    );
    starMesh.position.set(0,CONFIG.tree.height/2+2,0);
    scene.add(starMesh);

    // LOVE
    const cv2=document.createElement("canvas");
    cv2.width=1024; cv2.height=256;
    const c2=cv2.getContext("2d");
    c2.font=`bold ${isMobile?70:120}px Segoe UI`;
    c2.fillStyle="#FF69B4";
    c2.textAlign="center";
    c2.shadowColor="#FF1493"; c2.shadowBlur=40;
    c2.fillText("I LOVE YOU ‚ù§Ô∏è",512,140);

    loveMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(70,18),
        new THREE.MeshBasicMaterial({ map:new THREE.CanvasTexture(cv2), transparent:true })
    );
    loveMesh.visible=false;
    loveMesh.position.set(0,0,20);
    scene.add(loveMesh);
}

/* ============================================================
   üìå UPDATE STATE LOGIC (Particles + Photos)
============================================================ */
function updateStateLogic(t){
    smoothX += (handX-smoothX)*0.15;
    smoothY += (handY-smoothY)*0.15;

    if (state==="EXPLODE"){
        rotY += (smoothX-0.5)*0.04;
        rotX += -(smoothY-0.5)*0.04;
    } else {
        rotX*=0.9;
    }

    updateParticles(t);
    updatePhotos(t);
}

/* ============================================================
   üìå UPDATE PARTICLES (OPTIMIZED)
============================================================ */
function updateParticles(dt){
    const list=[groupGold,groupRed,groupGift];

    for (const g of list){
        const geo = g.geometry;
        const pos = geo.attributes.position.array;

        let target;
        if (state==="TREE") target=geo.userData.tree;
        else if (state==="HEART") target=geo.userData.heart;
        else target=geo.userData.explode;

        const speed = state==="EXPLODE"?0.1:0.07;

        for (let i=0;i<pos.length;i++){
            pos[i]+= (target[i]-pos[i])*speed;
        }
        geo.attributes.position.needsUpdate=true;

        if (state==="TREE"){
            g.rotation.y+=0.0025;
        } else if (state==="HEART"){
            const s = 1+Math.abs(Math.sin(dt*3))*0.15;
            g.scale.set(s,s,s);
        } else if (state==="EXPLODE"){
            g.rotation.x=rotX;
            g.rotation.y=rotY;
        }
    }
}

/* ============================================================
   üìå UPDATE PHOTOS (OPTIMIZED)
============================================================ */
function updatePhotos(dt){
    if (state==="TREE"){
        loveMesh.visible=false;
        titleMesh.visible=true;
        starMesh.visible=true;

        photoMeshes.forEach(m=>{
            m.visible=false;
            m.scale.lerp(new THREE.Vector3(0,0,0),0.18);
        });
        return;
    }

    if (state==="HEART"){
        titleMesh.visible=false;
        starMesh.visible=false;
        loveMesh.visible=true;

        loveMesh.scale.set(
            1+Math.abs(Math.sin(dt*3))*0.1,
            1+Math.abs(Math.sin(dt*3))*0.1,
            1
        );
        return;
    }

    // EXPLODE / PHOTO mode
    titleMesh.visible=false;
    starMesh.visible=false;
    loveMesh.visible=false;

    let bestZ=-9999;
    let best=0;

    const e = new THREE.Euler(rotX,rotY,0,"YXZ");

    photoMeshes.forEach((m,i)=>{
        m.visible=true;

        const v = m.userData.origin.clone();
        v.applyEuler(e);
        m.position.lerp(v,0.15);

        if (v.z > bestZ){ bestZ=v.z; best=i; }

        let s = (v.z > CONFIG.baseRadius-10)?0.28:0.15;
        if (isMobile) s*=1.25;
        m.scale.lerp(new THREE.Vector3(s,s,s),0.15);
    });

    bestPhoto=best;

    if (state==="PHOTO"){
        photoMeshes.forEach((m,i)=>{
            if (i===bestPhoto){
                const zoomZ = camera.position.z-40;
                m.position.lerp(new THREE.Vector3(0,0,zoomZ),0.1);

                const zoom = isMobile?3:5;
                m.scale.lerp(new THREE.Vector3(zoom,zoom,zoom),0.1);

            } else {
                m.scale.lerp(new THREE.Vector3(0,0,0),0.2);
            }
        });
    }
}

/* ============================================================
   üìå HAND DETECTION (OPTIMIZED FPS)
============================================================ */
function startHandTracking(){
    const video=document.querySelector(".input_video");
    const canvas=document.getElementById("camera-preview");
    const ctx=canvas.getContext("2d");

    canvas.width=320; canvas.height=240;

    const hands = new Hands({
        locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
    });

    hands.setOptions({
        maxNumHands:2,
        modelComplexity:isMobile?0:1,
        minDetectionConfidence:0.5,
        minTrackingConfidence:0.5
    });

    hands.onResults(res=>{
        if (!res.image) return;

        ctx.save();
        ctx.scale(-1,1);
        ctx.drawImage(res.image, -canvas.width, 0, canvas.width, canvas.height);
        ctx.restore();

        if (!res.multiHandLandmarks.length) return;

        const lm = res.multiHandLandmarks[0];
        handX = lm[9].x;
        handY = lm[9].y;

        // Gesture
        const wrist=lm[0];
        const tips=[8,12,16,20];
        let sum=0;
        for (const t of tips){
            sum+=Math.hypot(lm[t].x-wrist.x, lm[t].y-wrist.y);
        }
        const openDist=sum/4;
        const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);

        if (openDist<0.23) state="TREE";
        else if (pinch<0.05) state="PHOTO";
        else state="EXPLODE";
    });

    new Camera(video,{
        onFrame:async()=>{ await hands.send({image:video}); },
        width:640, height:480, facingMode:"user"
    }).start();
}

/* ============================================================
   üìå RENDER LOOP
============================================================ */
function animate(t=0){
    requestAnimationFrame(animate);

    if (t-lastLogic>LOGIC_INTERVAL){
        lastLogic=t;
        updateStateLogic(t*0.001);
    }

    renderer.render(scene,camera);
}

/* ============================================================
   üìå START SYSTEM
============================================================ */
function startSystem(){
    document.getElementById("btnStart").style.display="none";

    const audio=new Audio(CONFIG.audio);
    audio.loop=true; audio.volume=1;
    audio.play().catch(()=>{});

    init3D();
    startHandTracking();
}

/* ============================================================
   üìå RESIZE
============================================================ */
window.addEventListener("resize",()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
    setCameraDist();
});
</script>

</body>
</html>
